import { LowerCasePipe } from '@angular/common';
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { combineLatest, concatMap, filter, Observable, BehaviorSubject, map, tap, of, catchError } from 'rxjs';
import { IProductDetailsDto, ProductDetailsDto } from './product-details/product-details.dto';

interface IProductFilter {
  isSatisfied(product: IProductDetailsDto): boolean;
}

interface ProductResponse {
  product: IProductDetailsDto;
}

interface IUserSelections {
  name?: string;
}

interface IProductUpdateDto {
  description?: string;
  price?: number;
}

// Generated by https://quicktype.io
export interface IProductUpdateResponse {
  statusCode: number;
  message:    string;
}


@Injectable({
  providedIn: 'root'
})
export class ProductService {
  private _userSelections$: BehaviorSubject<IUserSelections> = new BehaviorSubject<IUserSelections>({name: 'macbook'});
  private _userSelections: IUserSelections = {};
  public set userSelections(selections: IUserSelections) {
    Object.assign(this._userSelections, selections);
    this._userSelections$.next(this._userSelections);
  }

  filter: BehaviorSubject<IProductFilter[]> = new BehaviorSubject<IProductFilter[]>([]);
  _products$: BehaviorSubject<IProductDetailsDto[]> = new BehaviorSubject<IProductDetailsDto[]>([])
  products$: Observable<IProductDetailsDto[]> = combineLatest([this.filter, this._products$]).pipe(
    concatMap(([filtr, products]) => {
      return this.getProducts(filtr).pipe(
        map((serverProducts: IProductDetailsDto[]) => {
          return serverProducts.concat(products);
        })        
      )
    }),
  )
  productCache: {[key:string]: IProductDetailsDto} = {};

  constructor(
    private http: HttpClient,
    private lowerCase: LowerCasePipe,
  ) { }

  getProducts(filter: IProductFilter[] = []): Observable<IProductDetailsDto[]> {
    return this.http.get<IProductDetailsDto[]>('/api/products').pipe(
      map((products: IProductDetailsDto[]) => {
        return products.filter(p => {
          const unsatisfiedFilters = filter.filter(f => !f.isSatisfied(p));
          return unsatisfiedFilters.length === 0;
        })
      }),
    );
  }

  getProduct(name?: string): Observable<IProductDetailsDto> {
    let productName: string;
    productName = name ?? this._userSelections.name ?? '';
    productName = this.lowerCase.transform(productName);
    if(productName in this.productCache) return of(this.productCache[productName]);
    return this.http.get<ProductResponse>(`/api/products/${name}`).pipe(
      map((res: ProductResponse) => {
        return res.product;
      }),
      tap((product: IProductDetailsDto) => {
        this.productCache[productName] = product;
      })
    );
  }  

  updateProduct(name: string, product: IProductDetailsDto): Observable<IProductDetailsDto> {
    let productName: string;
    productName = name ?? this._userSelections.name ?? '';
    productName = this.lowerCase.transform(productName);
    const updateDto: IProductUpdateDto = {
      description: product.description,
      price: product.price,
    }
    return this.http.patch<ProductResponse>(`/api/products/${name}`, updateDto).pipe(
      map((res: ProductResponse) => {
        return res.product;
      }),
      tap((res: IProductDetailsDto) => {
        this.filter.next([]);
      })
    );
  }  

  deleteProduct(name: string): Observable<IProductDetailsDto> {
    let productName: string;
    productName = name ?? this._userSelections.name ?? '';
    productName = this.lowerCase.transform(productName);
    return this.http.delete<ProductResponse>(`/api/products/${name}`).pipe(
      map((res: ProductResponse) => {
        return res.product;
      }),
      tap((res: IProductDetailsDto) => {
        this.filter.next([]);
      })
    );
  }    

  createProduct(product: IProductDetailsDto): Observable<IProductUpdateResponse> {
    return this.http.post<IProductUpdateResponse>(`/api/products`, product).pipe(
      map((res: IProductUpdateResponse) => {
        return res;
      }),
      tap((res: IProductUpdateResponse) => {
        this.filter.next([]);
      })
    );
  }  

}
